# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _itkPyBufferPython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_itkPyBufferPython', [dirname(__file__)])
        except ImportError:
            import _itkPyBufferPython
            return _itkPyBufferPython
        if fp is not None:
            try:
                _mod = imp.load_module('_itkPyBufferPython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _itkPyBufferPython = swig_import_helper()
    del swig_import_helper
else:
    import _itkPyBufferPython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import vnl_vectorPython
import vnl_matrixPython
import stdcomplexPython
import pyBasePython
import itkVectorImagePython
import itkImagePython
import itkOffsetPython
import itkSizePython
import itkPointPython
import vnl_vector_refPython
import itkVectorPython
import itkFixedArrayPython
import itkMatrixPython
import vnl_matrix_fixedPython
import itkCovariantVectorPython
import itkSymmetricSecondRankTensorPython
import ITKCommonBasePython
import itkImageRegionPython
import itkIndexPython
import itkRGBPixelPython
import itkRGBAPixelPython
import itkVariableLengthVectorPython


HAVE_NUMPY = True
try:
  import numpy
except ImportError:
  HAVE_NUMPY = False

def _get_numpy_pixelid(itk_Image_type):
    """Returns a ITK PixelID given a numpy array."""

    if not HAVE_NUMPY:
        raise ImportError('Numpy not available.')
# This is a Mapping from numpy array types to itk pixel types.
    _np_itk = {"UC":numpy.uint8,
               "US":numpy.uint16,
               "UI":numpy.uint32,
               "UL":numpy.uint64,
               "SC":numpy.int8,
               "SS":numpy.int16,
               "SI":numpy.int32,
               "SL":numpy.int64,
               "F":numpy.float32,
               "D":numpy.float64,
                }
    import os
    if os.name == 'nt':
        _np_itk['UL'] = numpy.uint32
        _np_itk['SL'] = numpy.int32
    try:
        return _np_itk[itk_Image_type]
    except KeyError as e:
        raise e

from itkImageDuplicatorPython import *

class itkPyBufferICVF22(object):
    """Proxy of C++ itkPyBufferICVF22 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVF22') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVF22 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVF22__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF22_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF22_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVF22__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVF22 self) -> itkPyBufferICVF22
        __init__(itkPyBufferICVF22 self, itkPyBufferICVF22 arg0) -> itkPyBufferICVF22
        """
        _itkPyBufferPython.itkPyBufferICVF22_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF22._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF22._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF22._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVF22._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF22.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVF22.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVF22_swigregister = _itkPyBufferPython.itkPyBufferICVF22_swigregister
itkPyBufferICVF22_swigregister(itkPyBufferICVF22)

def itkPyBufferICVF22__GetArrayViewFromImage(image: 'itkImageCVF22') -> "PyObject *":
    """itkPyBufferICVF22__GetArrayViewFromImage(itkImageCVF22 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVF22__GetArrayViewFromImage(image)

def itkPyBufferICVF22__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF22_Pointer const":
    """itkPyBufferICVF22__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF22_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVF22__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVF23(object):
    """Proxy of C++ itkPyBufferICVF23 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVF23') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVF23 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVF23__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF23_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF23_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVF23__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVF23 self) -> itkPyBufferICVF23
        __init__(itkPyBufferICVF23 self, itkPyBufferICVF23 arg0) -> itkPyBufferICVF23
        """
        _itkPyBufferPython.itkPyBufferICVF23_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF23._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF23._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF23._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVF23._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF23.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVF23.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVF23_swigregister = _itkPyBufferPython.itkPyBufferICVF23_swigregister
itkPyBufferICVF23_swigregister(itkPyBufferICVF23)

def itkPyBufferICVF23__GetArrayViewFromImage(image: 'itkImageCVF23') -> "PyObject *":
    """itkPyBufferICVF23__GetArrayViewFromImage(itkImageCVF23 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVF23__GetArrayViewFromImage(image)

def itkPyBufferICVF23__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF23_Pointer const":
    """itkPyBufferICVF23__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF23_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVF23__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVF32(object):
    """Proxy of C++ itkPyBufferICVF32 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVF32') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVF32 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVF32__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF32_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF32_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVF32__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVF32 self) -> itkPyBufferICVF32
        __init__(itkPyBufferICVF32 self, itkPyBufferICVF32 arg0) -> itkPyBufferICVF32
        """
        _itkPyBufferPython.itkPyBufferICVF32_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF32._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF32._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF32._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVF32._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF32.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVF32.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVF32_swigregister = _itkPyBufferPython.itkPyBufferICVF32_swigregister
itkPyBufferICVF32_swigregister(itkPyBufferICVF32)

def itkPyBufferICVF32__GetArrayViewFromImage(image: 'itkImageCVF32') -> "PyObject *":
    """itkPyBufferICVF32__GetArrayViewFromImage(itkImageCVF32 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVF32__GetArrayViewFromImage(image)

def itkPyBufferICVF32__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF32_Pointer const":
    """itkPyBufferICVF32__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF32_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVF32__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVF33(object):
    """Proxy of C++ itkPyBufferICVF33 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVF33') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVF33 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVF33__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF33_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF33_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVF33__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVF33 self) -> itkPyBufferICVF33
        __init__(itkPyBufferICVF33 self, itkPyBufferICVF33 arg0) -> itkPyBufferICVF33
        """
        _itkPyBufferPython.itkPyBufferICVF33_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF33._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF33._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF33._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVF33._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF33.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVF33.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVF33_swigregister = _itkPyBufferPython.itkPyBufferICVF33_swigregister
itkPyBufferICVF33_swigregister(itkPyBufferICVF33)

def itkPyBufferICVF33__GetArrayViewFromImage(image: 'itkImageCVF33') -> "PyObject *":
    """itkPyBufferICVF33__GetArrayViewFromImage(itkImageCVF33 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVF33__GetArrayViewFromImage(image)

def itkPyBufferICVF33__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF33_Pointer const":
    """itkPyBufferICVF33__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF33_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVF33__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVF42(object):
    """Proxy of C++ itkPyBufferICVF42 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVF42') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVF42 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVF42__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF42_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF42_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVF42__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVF42 self) -> itkPyBufferICVF42
        __init__(itkPyBufferICVF42 self, itkPyBufferICVF42 arg0) -> itkPyBufferICVF42
        """
        _itkPyBufferPython.itkPyBufferICVF42_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF42._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF42._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF42._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVF42._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF42.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVF42.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVF42_swigregister = _itkPyBufferPython.itkPyBufferICVF42_swigregister
itkPyBufferICVF42_swigregister(itkPyBufferICVF42)

def itkPyBufferICVF42__GetArrayViewFromImage(image: 'itkImageCVF42') -> "PyObject *":
    """itkPyBufferICVF42__GetArrayViewFromImage(itkImageCVF42 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVF42__GetArrayViewFromImage(image)

def itkPyBufferICVF42__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF42_Pointer const":
    """itkPyBufferICVF42__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF42_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVF42__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVF43(object):
    """Proxy of C++ itkPyBufferICVF43 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVF43') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVF43 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVF43__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF43_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF43_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVF43__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVF43 self) -> itkPyBufferICVF43
        __init__(itkPyBufferICVF43 self, itkPyBufferICVF43 arg0) -> itkPyBufferICVF43
        """
        _itkPyBufferPython.itkPyBufferICVF43_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF43._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF43._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF43._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVF43._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF43.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVF43.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVF43_swigregister = _itkPyBufferPython.itkPyBufferICVF43_swigregister
itkPyBufferICVF43_swigregister(itkPyBufferICVF43)

def itkPyBufferICVF43__GetArrayViewFromImage(image: 'itkImageCVF43') -> "PyObject *":
    """itkPyBufferICVF43__GetArrayViewFromImage(itkImageCVF43 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVF43__GetArrayViewFromImage(image)

def itkPyBufferICVF43__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF43_Pointer const":
    """itkPyBufferICVF43__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF43_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVF43__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferID2(object):
    """Proxy of C++ itkPyBufferID2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageD2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageD2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferID2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageD2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageD2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferID2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferID2 self) -> itkPyBufferID2
        __init__(itkPyBufferID2 self, itkPyBufferID2 arg0) -> itkPyBufferID2
        """
        _itkPyBufferPython.itkPyBufferID2_swiginit(self, _itkPyBufferPython.new_itkPyBufferID2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferID2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "D"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferID2._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferID2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferID2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferID2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferID2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferID2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorID2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferID2_swigregister = _itkPyBufferPython.itkPyBufferID2_swigregister
itkPyBufferID2_swigregister(itkPyBufferID2)

def itkPyBufferID2__GetArrayViewFromImage(image: 'itkImageD2') -> "PyObject *":
    """itkPyBufferID2__GetArrayViewFromImage(itkImageD2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferID2__GetArrayViewFromImage(image)

def itkPyBufferID2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageD2_Pointer const":
    """itkPyBufferID2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageD2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferID2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferID3(object):
    """Proxy of C++ itkPyBufferID3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageD3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageD3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferID3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageD3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageD3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferID3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferID3 self) -> itkPyBufferID3
        __init__(itkPyBufferID3 self, itkPyBufferID3 arg0) -> itkPyBufferID3
        """
        _itkPyBufferPython.itkPyBufferID3_swiginit(self, _itkPyBufferPython.new_itkPyBufferID3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferID3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "D"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferID3._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferID3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferID3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferID3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferID3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferID3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorID3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferID3_swigregister = _itkPyBufferPython.itkPyBufferID3_swigregister
itkPyBufferID3_swigregister(itkPyBufferID3)

def itkPyBufferID3__GetArrayViewFromImage(image: 'itkImageD3') -> "PyObject *":
    """itkPyBufferID3__GetArrayViewFromImage(itkImageD3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferID3__GetArrayViewFromImage(image)

def itkPyBufferID3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageD3_Pointer const":
    """itkPyBufferID3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageD3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferID3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIF2(object):
    """Proxy of C++ itkPyBufferIF2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageF2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageF2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIF2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageF2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageF2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIF2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIF2 self) -> itkPyBufferIF2
        __init__(itkPyBufferIF2 self, itkPyBufferIF2 arg0) -> itkPyBufferIF2
        """
        _itkPyBufferPython.itkPyBufferIF2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIF2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIF2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIF2._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIF2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIF2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIF2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIF2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIF2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIF2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIF2_swigregister = _itkPyBufferPython.itkPyBufferIF2_swigregister
itkPyBufferIF2_swigregister(itkPyBufferIF2)

def itkPyBufferIF2__GetArrayViewFromImage(image: 'itkImageF2') -> "PyObject *":
    """itkPyBufferIF2__GetArrayViewFromImage(itkImageF2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIF2__GetArrayViewFromImage(image)

def itkPyBufferIF2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageF2_Pointer const":
    """itkPyBufferIF2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageF2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIF2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIF3(object):
    """Proxy of C++ itkPyBufferIF3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageF3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageF3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIF3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageF3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageF3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIF3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIF3 self) -> itkPyBufferIF3
        __init__(itkPyBufferIF3 self, itkPyBufferIF3 arg0) -> itkPyBufferIF3
        """
        _itkPyBufferPython.itkPyBufferIF3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIF3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIF3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIF3._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIF3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIF3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIF3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIF3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIF3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIF3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIF3_swigregister = _itkPyBufferPython.itkPyBufferIF3_swigregister
itkPyBufferIF3_swigregister(itkPyBufferIF3)

def itkPyBufferIF3__GetArrayViewFromImage(image: 'itkImageF3') -> "PyObject *":
    """itkPyBufferIF3__GetArrayViewFromImage(itkImageF3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIF3__GetArrayViewFromImage(image)

def itkPyBufferIF3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageF3_Pointer const":
    """itkPyBufferIF3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageF3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIF3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIRGBAUC2(object):
    """Proxy of C++ itkPyBufferIRGBAUC2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageRGBAUC2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageRGBAUC2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIRGBAUC2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBAUC2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBAUC2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIRGBAUC2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIRGBAUC2 self) -> itkPyBufferIRGBAUC2
        __init__(itkPyBufferIRGBAUC2 self, itkPyBufferIRGBAUC2 arg0) -> itkPyBufferIRGBAUC2
        """
        _itkPyBufferPython.itkPyBufferIRGBAUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBAUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBAUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "UC"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBAUC2._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBAUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIRGBAUC2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIRGBAUC2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIRGBAUC2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBAUC2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIRGBAUC2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIRGBAUC2_swigregister = _itkPyBufferPython.itkPyBufferIRGBAUC2_swigregister
itkPyBufferIRGBAUC2_swigregister(itkPyBufferIRGBAUC2)

def itkPyBufferIRGBAUC2__GetArrayViewFromImage(image: 'itkImageRGBAUC2') -> "PyObject *":
    """itkPyBufferIRGBAUC2__GetArrayViewFromImage(itkImageRGBAUC2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIRGBAUC2__GetArrayViewFromImage(image)

def itkPyBufferIRGBAUC2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBAUC2_Pointer const":
    """itkPyBufferIRGBAUC2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBAUC2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIRGBAUC2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIRGBAUC3(object):
    """Proxy of C++ itkPyBufferIRGBAUC3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageRGBAUC3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageRGBAUC3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIRGBAUC3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBAUC3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBAUC3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIRGBAUC3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIRGBAUC3 self) -> itkPyBufferIRGBAUC3
        __init__(itkPyBufferIRGBAUC3 self, itkPyBufferIRGBAUC3 arg0) -> itkPyBufferIRGBAUC3
        """
        _itkPyBufferPython.itkPyBufferIRGBAUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBAUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBAUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "UC"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBAUC3._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBAUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIRGBAUC3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIRGBAUC3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIRGBAUC3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBAUC3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIRGBAUC3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIRGBAUC3_swigregister = _itkPyBufferPython.itkPyBufferIRGBAUC3_swigregister
itkPyBufferIRGBAUC3_swigregister(itkPyBufferIRGBAUC3)

def itkPyBufferIRGBAUC3__GetArrayViewFromImage(image: 'itkImageRGBAUC3') -> "PyObject *":
    """itkPyBufferIRGBAUC3__GetArrayViewFromImage(itkImageRGBAUC3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIRGBAUC3__GetArrayViewFromImage(image)

def itkPyBufferIRGBAUC3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBAUC3_Pointer const":
    """itkPyBufferIRGBAUC3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBAUC3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIRGBAUC3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIRGBUC2(object):
    """Proxy of C++ itkPyBufferIRGBUC2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageRGBUC2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageRGBUC2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIRGBUC2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBUC2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBUC2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIRGBUC2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIRGBUC2 self) -> itkPyBufferIRGBUC2
        __init__(itkPyBufferIRGBUC2 self, itkPyBufferIRGBUC2 arg0) -> itkPyBufferIRGBUC2
        """
        _itkPyBufferPython.itkPyBufferIRGBUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "UC"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBUC2._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIRGBUC2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIRGBUC2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIRGBUC2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBUC2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIRGBUC2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIRGBUC2_swigregister = _itkPyBufferPython.itkPyBufferIRGBUC2_swigregister
itkPyBufferIRGBUC2_swigregister(itkPyBufferIRGBUC2)

def itkPyBufferIRGBUC2__GetArrayViewFromImage(image: 'itkImageRGBUC2') -> "PyObject *":
    """itkPyBufferIRGBUC2__GetArrayViewFromImage(itkImageRGBUC2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIRGBUC2__GetArrayViewFromImage(image)

def itkPyBufferIRGBUC2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBUC2_Pointer const":
    """itkPyBufferIRGBUC2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBUC2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIRGBUC2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIRGBUC3(object):
    """Proxy of C++ itkPyBufferIRGBUC3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageRGBUC3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageRGBUC3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIRGBUC3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBUC3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBUC3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIRGBUC3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIRGBUC3 self) -> itkPyBufferIRGBUC3
        __init__(itkPyBufferIRGBUC3 self, itkPyBufferIRGBUC3 arg0) -> itkPyBufferIRGBUC3
        """
        _itkPyBufferPython.itkPyBufferIRGBUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "UC"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBUC3._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIRGBUC3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIRGBUC3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIRGBUC3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBUC3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIRGBUC3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIRGBUC3_swigregister = _itkPyBufferPython.itkPyBufferIRGBUC3_swigregister
itkPyBufferIRGBUC3_swigregister(itkPyBufferIRGBUC3)

def itkPyBufferIRGBUC3__GetArrayViewFromImage(image: 'itkImageRGBUC3') -> "PyObject *":
    """itkPyBufferIRGBUC3__GetArrayViewFromImage(itkImageRGBUC3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIRGBUC3__GetArrayViewFromImage(image)

def itkPyBufferIRGBUC3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBUC3_Pointer const":
    """itkPyBufferIRGBUC3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBUC3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIRGBUC3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferISS2(object):
    """Proxy of C++ itkPyBufferISS2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageSS2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageSS2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferISS2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSS2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSS2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferISS2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferISS2 self) -> itkPyBufferISS2
        __init__(itkPyBufferISS2 self, itkPyBufferISS2 arg0) -> itkPyBufferISS2
        """
        _itkPyBufferPython.itkPyBufferISS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferISS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "SS"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISS2._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferISS2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferISS2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferISS2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISS2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorISS2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferISS2_swigregister = _itkPyBufferPython.itkPyBufferISS2_swigregister
itkPyBufferISS2_swigregister(itkPyBufferISS2)

def itkPyBufferISS2__GetArrayViewFromImage(image: 'itkImageSS2') -> "PyObject *":
    """itkPyBufferISS2__GetArrayViewFromImage(itkImageSS2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferISS2__GetArrayViewFromImage(image)

def itkPyBufferISS2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSS2_Pointer const":
    """itkPyBufferISS2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSS2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferISS2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferISS3(object):
    """Proxy of C++ itkPyBufferISS3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageSS3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageSS3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferISS3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSS3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSS3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferISS3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferISS3 self) -> itkPyBufferISS3
        __init__(itkPyBufferISS3 self, itkPyBufferISS3 arg0) -> itkPyBufferISS3
        """
        _itkPyBufferPython.itkPyBufferISS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferISS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "SS"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISS3._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferISS3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferISS3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferISS3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISS3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorISS3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferISS3_swigregister = _itkPyBufferPython.itkPyBufferISS3_swigregister
itkPyBufferISS3_swigregister(itkPyBufferISS3)

def itkPyBufferISS3__GetArrayViewFromImage(image: 'itkImageSS3') -> "PyObject *":
    """itkPyBufferISS3__GetArrayViewFromImage(itkImageSS3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferISS3__GetArrayViewFromImage(image)

def itkPyBufferISS3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSS3_Pointer const":
    """itkPyBufferISS3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSS3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferISS3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferISSRTD22(object):
    """Proxy of C++ itkPyBufferISSRTD22 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageSSRTD22') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageSSRTD22 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferISSRTD22__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSSRTD22_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSSRTD22_Pointer const"""
        return _itkPyBufferPython.itkPyBufferISSRTD22__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferISSRTD22 self) -> itkPyBufferISSRTD22
        __init__(itkPyBufferISSRTD22 self, itkPyBufferISSRTD22 arg0) -> itkPyBufferISSRTD22
        """
        _itkPyBufferPython.itkPyBufferISSRTD22_swiginit(self, _itkPyBufferPython.new_itkPyBufferISSRTD22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISSRTD22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "D"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISSRTD22._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISSRTD22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferISSRTD22._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferISSRTD22._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferISSRTD22._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISSRTD22.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorISSRTD22.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferISSRTD22_swigregister = _itkPyBufferPython.itkPyBufferISSRTD22_swigregister
itkPyBufferISSRTD22_swigregister(itkPyBufferISSRTD22)

def itkPyBufferISSRTD22__GetArrayViewFromImage(image: 'itkImageSSRTD22') -> "PyObject *":
    """itkPyBufferISSRTD22__GetArrayViewFromImage(itkImageSSRTD22 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferISSRTD22__GetArrayViewFromImage(image)

def itkPyBufferISSRTD22__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSSRTD22_Pointer const":
    """itkPyBufferISSRTD22__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSSRTD22_Pointer const"""
    return _itkPyBufferPython.itkPyBufferISSRTD22__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferISSRTD33(object):
    """Proxy of C++ itkPyBufferISSRTD33 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageSSRTD33') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageSSRTD33 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferISSRTD33__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSSRTD33_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSSRTD33_Pointer const"""
        return _itkPyBufferPython.itkPyBufferISSRTD33__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferISSRTD33 self) -> itkPyBufferISSRTD33
        __init__(itkPyBufferISSRTD33 self, itkPyBufferISSRTD33 arg0) -> itkPyBufferISSRTD33
        """
        _itkPyBufferPython.itkPyBufferISSRTD33_swiginit(self, _itkPyBufferPython.new_itkPyBufferISSRTD33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISSRTD33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "D"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISSRTD33._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISSRTD33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferISSRTD33._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferISSRTD33._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferISSRTD33._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISSRTD33.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorISSRTD33.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferISSRTD33_swigregister = _itkPyBufferPython.itkPyBufferISSRTD33_swigregister
itkPyBufferISSRTD33_swigregister(itkPyBufferISSRTD33)

def itkPyBufferISSRTD33__GetArrayViewFromImage(image: 'itkImageSSRTD33') -> "PyObject *":
    """itkPyBufferISSRTD33__GetArrayViewFromImage(itkImageSSRTD33 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferISSRTD33__GetArrayViewFromImage(image)

def itkPyBufferISSRTD33__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSSRTD33_Pointer const":
    """itkPyBufferISSRTD33__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSSRTD33_Pointer const"""
    return _itkPyBufferPython.itkPyBufferISSRTD33__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIUC2(object):
    """Proxy of C++ itkPyBufferIUC2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageUC2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageUC2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIUC2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUC2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUC2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIUC2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIUC2 self) -> itkPyBufferIUC2
        __init__(itkPyBufferIUC2 self, itkPyBufferIUC2 arg0) -> itkPyBufferIUC2
        """
        _itkPyBufferPython.itkPyBufferIUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "UC"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUC2._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUC2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUC2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIUC2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUC2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIUC2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIUC2_swigregister = _itkPyBufferPython.itkPyBufferIUC2_swigregister
itkPyBufferIUC2_swigregister(itkPyBufferIUC2)

def itkPyBufferIUC2__GetArrayViewFromImage(image: 'itkImageUC2') -> "PyObject *":
    """itkPyBufferIUC2__GetArrayViewFromImage(itkImageUC2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIUC2__GetArrayViewFromImage(image)

def itkPyBufferIUC2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUC2_Pointer const":
    """itkPyBufferIUC2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUC2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIUC2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIUC3(object):
    """Proxy of C++ itkPyBufferIUC3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageUC3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageUC3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIUC3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUC3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUC3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIUC3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIUC3 self) -> itkPyBufferIUC3
        __init__(itkPyBufferIUC3 self, itkPyBufferIUC3 arg0) -> itkPyBufferIUC3
        """
        _itkPyBufferPython.itkPyBufferIUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "UC"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUC3._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUC3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUC3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIUC3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUC3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIUC3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIUC3_swigregister = _itkPyBufferPython.itkPyBufferIUC3_swigregister
itkPyBufferIUC3_swigregister(itkPyBufferIUC3)

def itkPyBufferIUC3__GetArrayViewFromImage(image: 'itkImageUC3') -> "PyObject *":
    """itkPyBufferIUC3__GetArrayViewFromImage(itkImageUC3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIUC3__GetArrayViewFromImage(image)

def itkPyBufferIUC3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUC3_Pointer const":
    """itkPyBufferIUC3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUC3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIUC3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIUL2(object):
    """Proxy of C++ itkPyBufferIUL2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageUL2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageUL2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIUL2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUL2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUL2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIUL2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIUL2 self) -> itkPyBufferIUL2
        __init__(itkPyBufferIUL2 self, itkPyBufferIUL2 arg0) -> itkPyBufferIUL2
        """
        _itkPyBufferPython.itkPyBufferIUL2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUL2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUL2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "UL"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUL2._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUL2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUL2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUL2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIUL2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUL2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIUL2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIUL2_swigregister = _itkPyBufferPython.itkPyBufferIUL2_swigregister
itkPyBufferIUL2_swigregister(itkPyBufferIUL2)

def itkPyBufferIUL2__GetArrayViewFromImage(image: 'itkImageUL2') -> "PyObject *":
    """itkPyBufferIUL2__GetArrayViewFromImage(itkImageUL2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIUL2__GetArrayViewFromImage(image)

def itkPyBufferIUL2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUL2_Pointer const":
    """itkPyBufferIUL2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUL2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIUL2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIUL3(object):
    """Proxy of C++ itkPyBufferIUL3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageUL3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageUL3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIUL3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUL3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUL3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIUL3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIUL3 self) -> itkPyBufferIUL3
        __init__(itkPyBufferIUL3 self, itkPyBufferIUL3 arg0) -> itkPyBufferIUL3
        """
        _itkPyBufferPython.itkPyBufferIUL3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUL3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUL3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "UL"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUL3._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUL3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUL3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUL3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIUL3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUL3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIUL3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIUL3_swigregister = _itkPyBufferPython.itkPyBufferIUL3_swigregister
itkPyBufferIUL3_swigregister(itkPyBufferIUL3)

def itkPyBufferIUL3__GetArrayViewFromImage(image: 'itkImageUL3') -> "PyObject *":
    """itkPyBufferIUL3__GetArrayViewFromImage(itkImageUL3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIUL3__GetArrayViewFromImage(image)

def itkPyBufferIUL3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUL3_Pointer const":
    """itkPyBufferIUL3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUL3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIUL3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIUS2(object):
    """Proxy of C++ itkPyBufferIUS2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageUS2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageUS2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIUS2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUS2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUS2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIUS2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIUS2 self) -> itkPyBufferIUS2
        __init__(itkPyBufferIUS2 self, itkPyBufferIUS2 arg0) -> itkPyBufferIUS2
        """
        _itkPyBufferPython.itkPyBufferIUS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "US"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUS2._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUS2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUS2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIUS2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUS2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIUS2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIUS2_swigregister = _itkPyBufferPython.itkPyBufferIUS2_swigregister
itkPyBufferIUS2_swigregister(itkPyBufferIUS2)

def itkPyBufferIUS2__GetArrayViewFromImage(image: 'itkImageUS2') -> "PyObject *":
    """itkPyBufferIUS2__GetArrayViewFromImage(itkImageUS2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIUS2__GetArrayViewFromImage(image)

def itkPyBufferIUS2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUS2_Pointer const":
    """itkPyBufferIUS2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUS2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIUS2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIUS3(object):
    """Proxy of C++ itkPyBufferIUS3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageUS3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageUS3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIUS3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUS3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUS3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIUS3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIUS3 self) -> itkPyBufferIUS3
        __init__(itkPyBufferIUS3 self, itkPyBufferIUS3 arg0) -> itkPyBufferIUS3
        """
        _itkPyBufferPython.itkPyBufferIUS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "US"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUS3._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUS3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUS3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIUS3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUS3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIUS3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIUS3_swigregister = _itkPyBufferPython.itkPyBufferIUS3_swigregister
itkPyBufferIUS3_swigregister(itkPyBufferIUS3)

def itkPyBufferIUS3__GetArrayViewFromImage(image: 'itkImageUS3') -> "PyObject *":
    """itkPyBufferIUS3__GetArrayViewFromImage(itkImageUS3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIUS3__GetArrayViewFromImage(image)

def itkPyBufferIUS3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUS3_Pointer const":
    """itkPyBufferIUS3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUS3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIUS3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVF22(object):
    """Proxy of C++ itkPyBufferIVF22 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVF22') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVF22 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVF22__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF22_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF22_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVF22__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVF22 self) -> itkPyBufferIVF22
        __init__(itkPyBufferIVF22 self, itkPyBufferIVF22 arg0) -> itkPyBufferIVF22
        """
        _itkPyBufferPython.itkPyBufferIVF22_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF22._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF22._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF22._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVF22._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF22.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVF22.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVF22_swigregister = _itkPyBufferPython.itkPyBufferIVF22_swigregister
itkPyBufferIVF22_swigregister(itkPyBufferIVF22)

def itkPyBufferIVF22__GetArrayViewFromImage(image: 'itkImageVF22') -> "PyObject *":
    """itkPyBufferIVF22__GetArrayViewFromImage(itkImageVF22 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVF22__GetArrayViewFromImage(image)

def itkPyBufferIVF22__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF22_Pointer const":
    """itkPyBufferIVF22__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF22_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVF22__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVF23(object):
    """Proxy of C++ itkPyBufferIVF23 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVF23') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVF23 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVF23__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF23_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF23_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVF23__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVF23 self) -> itkPyBufferIVF23
        __init__(itkPyBufferIVF23 self, itkPyBufferIVF23 arg0) -> itkPyBufferIVF23
        """
        _itkPyBufferPython.itkPyBufferIVF23_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF23._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF23._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF23._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVF23._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF23.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVF23.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVF23_swigregister = _itkPyBufferPython.itkPyBufferIVF23_swigregister
itkPyBufferIVF23_swigregister(itkPyBufferIVF23)

def itkPyBufferIVF23__GetArrayViewFromImage(image: 'itkImageVF23') -> "PyObject *":
    """itkPyBufferIVF23__GetArrayViewFromImage(itkImageVF23 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVF23__GetArrayViewFromImage(image)

def itkPyBufferIVF23__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF23_Pointer const":
    """itkPyBufferIVF23__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF23_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVF23__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVF32(object):
    """Proxy of C++ itkPyBufferIVF32 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVF32') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVF32 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVF32__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF32_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF32_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVF32__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVF32 self) -> itkPyBufferIVF32
        __init__(itkPyBufferIVF32 self, itkPyBufferIVF32 arg0) -> itkPyBufferIVF32
        """
        _itkPyBufferPython.itkPyBufferIVF32_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF32._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF32._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF32._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVF32._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF32.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVF32.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVF32_swigregister = _itkPyBufferPython.itkPyBufferIVF32_swigregister
itkPyBufferIVF32_swigregister(itkPyBufferIVF32)

def itkPyBufferIVF32__GetArrayViewFromImage(image: 'itkImageVF32') -> "PyObject *":
    """itkPyBufferIVF32__GetArrayViewFromImage(itkImageVF32 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVF32__GetArrayViewFromImage(image)

def itkPyBufferIVF32__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF32_Pointer const":
    """itkPyBufferIVF32__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF32_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVF32__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVF33(object):
    """Proxy of C++ itkPyBufferIVF33 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVF33') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVF33 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVF33__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF33_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF33_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVF33__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVF33 self) -> itkPyBufferIVF33
        __init__(itkPyBufferIVF33 self, itkPyBufferIVF33 arg0) -> itkPyBufferIVF33
        """
        _itkPyBufferPython.itkPyBufferIVF33_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF33._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF33._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF33._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVF33._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF33.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVF33.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVF33_swigregister = _itkPyBufferPython.itkPyBufferIVF33_swigregister
itkPyBufferIVF33_swigregister(itkPyBufferIVF33)

def itkPyBufferIVF33__GetArrayViewFromImage(image: 'itkImageVF33') -> "PyObject *":
    """itkPyBufferIVF33__GetArrayViewFromImage(itkImageVF33 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVF33__GetArrayViewFromImage(image)

def itkPyBufferIVF33__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF33_Pointer const":
    """itkPyBufferIVF33__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF33_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVF33__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVF42(object):
    """Proxy of C++ itkPyBufferIVF42 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVF42') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVF42 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVF42__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF42_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF42_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVF42__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVF42 self) -> itkPyBufferIVF42
        __init__(itkPyBufferIVF42 self, itkPyBufferIVF42 arg0) -> itkPyBufferIVF42
        """
        _itkPyBufferPython.itkPyBufferIVF42_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF42._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF42._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF42._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVF42._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF42.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVF42.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVF42_swigregister = _itkPyBufferPython.itkPyBufferIVF42_swigregister
itkPyBufferIVF42_swigregister(itkPyBufferIVF42)

def itkPyBufferIVF42__GetArrayViewFromImage(image: 'itkImageVF42') -> "PyObject *":
    """itkPyBufferIVF42__GetArrayViewFromImage(itkImageVF42 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVF42__GetArrayViewFromImage(image)

def itkPyBufferIVF42__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF42_Pointer const":
    """itkPyBufferIVF42__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF42_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVF42__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVF43(object):
    """Proxy of C++ itkPyBufferIVF43 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVF43') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVF43 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVF43__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF43_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF43_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVF43__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVF43 self) -> itkPyBufferIVF43
        __init__(itkPyBufferIVF43 self, itkPyBufferIVF43 arg0) -> itkPyBufferIVF43
        """
        _itkPyBufferPython.itkPyBufferIVF43_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF43._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF43._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF43._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVF43._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF43.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVF43.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVF43_swigregister = _itkPyBufferPython.itkPyBufferIVF43_swigregister
itkPyBufferIVF43_swigregister(itkPyBufferIVF43)

def itkPyBufferIVF43__GetArrayViewFromImage(image: 'itkImageVF43') -> "PyObject *":
    """itkPyBufferIVF43__GetArrayViewFromImage(itkImageVF43 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVF43__GetArrayViewFromImage(image)

def itkPyBufferIVF43__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF43_Pointer const":
    """itkPyBufferIVF43__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF43_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVF43__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVIF2(object):
    """Proxy of C++ itkPyBufferVIF2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageF2') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageF2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVIF2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< float >,2 > > const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< float >,2 > > const"""
        return _itkPyBufferPython.itkPyBufferVIF2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVIF2 self) -> itkPyBufferVIF2
        __init__(itkPyBufferVIF2 self, itkPyBufferVIF2 arg0) -> itkPyBufferVIF2
        """
        _itkPyBufferPython.itkPyBufferVIF2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIF2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIF2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIF2._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIF2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIF2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIF2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVIF2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIF2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVIF2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVIF2_swigregister = _itkPyBufferPython.itkPyBufferVIF2_swigregister
itkPyBufferVIF2_swigregister(itkPyBufferVIF2)

def itkPyBufferVIF2__GetArrayViewFromImage(image: 'itkVectorImageF2') -> "PyObject *":
    """itkPyBufferVIF2__GetArrayViewFromImage(itkVectorImageF2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVIF2__GetArrayViewFromImage(image)

def itkPyBufferVIF2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< float >,2 > > const":
    """itkPyBufferVIF2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< float >,2 > > const"""
    return _itkPyBufferPython.itkPyBufferVIF2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVIF3(object):
    """Proxy of C++ itkPyBufferVIF3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageF3') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageF3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVIF3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< float >,3 > > const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< float >,3 > > const"""
        return _itkPyBufferPython.itkPyBufferVIF3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVIF3 self) -> itkPyBufferVIF3
        __init__(itkPyBufferVIF3 self, itkPyBufferVIF3 arg0) -> itkPyBufferVIF3
        """
        _itkPyBufferPython.itkPyBufferVIF3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIF3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIF3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIF3._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIF3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIF3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIF3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVIF3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIF3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVIF3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVIF3_swigregister = _itkPyBufferPython.itkPyBufferVIF3_swigregister
itkPyBufferVIF3_swigregister(itkPyBufferVIF3)

def itkPyBufferVIF3__GetArrayViewFromImage(image: 'itkVectorImageF3') -> "PyObject *":
    """itkPyBufferVIF3__GetArrayViewFromImage(itkVectorImageF3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVIF3__GetArrayViewFromImage(image)

def itkPyBufferVIF3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< float >,3 > > const":
    """itkPyBufferVIF3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< float >,3 > > const"""
    return _itkPyBufferPython.itkPyBufferVIF3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVISS2(object):
    """Proxy of C++ itkPyBufferVISS2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageSS2') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageSS2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVISS2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< short >,2 > > const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< short >,2 > > const"""
        return _itkPyBufferPython.itkPyBufferVISS2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVISS2 self) -> itkPyBufferVISS2
        __init__(itkPyBufferVISS2 self, itkPyBufferVISS2 arg0) -> itkPyBufferVISS2
        """
        _itkPyBufferPython.itkPyBufferVISS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVISS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVISS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "SS"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVISS2._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVISS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVISS2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVISS2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVISS2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVISS2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVISS2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVISS2_swigregister = _itkPyBufferPython.itkPyBufferVISS2_swigregister
itkPyBufferVISS2_swigregister(itkPyBufferVISS2)

def itkPyBufferVISS2__GetArrayViewFromImage(image: 'itkVectorImageSS2') -> "PyObject *":
    """itkPyBufferVISS2__GetArrayViewFromImage(itkVectorImageSS2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVISS2__GetArrayViewFromImage(image)

def itkPyBufferVISS2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< short >,2 > > const":
    """itkPyBufferVISS2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< short >,2 > > const"""
    return _itkPyBufferPython.itkPyBufferVISS2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVISS3(object):
    """Proxy of C++ itkPyBufferVISS3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageSS3') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageSS3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVISS3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< short >,3 > > const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< short >,3 > > const"""
        return _itkPyBufferPython.itkPyBufferVISS3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVISS3 self) -> itkPyBufferVISS3
        __init__(itkPyBufferVISS3 self, itkPyBufferVISS3 arg0) -> itkPyBufferVISS3
        """
        _itkPyBufferPython.itkPyBufferVISS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVISS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVISS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "SS"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVISS3._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVISS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVISS3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVISS3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVISS3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVISS3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVISS3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVISS3_swigregister = _itkPyBufferPython.itkPyBufferVISS3_swigregister
itkPyBufferVISS3_swigregister(itkPyBufferVISS3)

def itkPyBufferVISS3__GetArrayViewFromImage(image: 'itkVectorImageSS3') -> "PyObject *":
    """itkPyBufferVISS3__GetArrayViewFromImage(itkVectorImageSS3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVISS3__GetArrayViewFromImage(image)

def itkPyBufferVISS3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< short >,3 > > const":
    """itkPyBufferVISS3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< short >,3 > > const"""
    return _itkPyBufferPython.itkPyBufferVISS3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVIUC2(object):
    """Proxy of C++ itkPyBufferVIUC2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageUC2') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageUC2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVIUC2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned char >,2 > > const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned char >,2 > > const"""
        return _itkPyBufferPython.itkPyBufferVIUC2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVIUC2 self) -> itkPyBufferVIUC2
        __init__(itkPyBufferVIUC2 self, itkPyBufferVIUC2 arg0) -> itkPyBufferVIUC2
        """
        _itkPyBufferPython.itkPyBufferVIUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "UC"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUC2._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIUC2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIUC2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVIUC2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUC2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVIUC2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVIUC2_swigregister = _itkPyBufferPython.itkPyBufferVIUC2_swigregister
itkPyBufferVIUC2_swigregister(itkPyBufferVIUC2)

def itkPyBufferVIUC2__GetArrayViewFromImage(image: 'itkVectorImageUC2') -> "PyObject *":
    """itkPyBufferVIUC2__GetArrayViewFromImage(itkVectorImageUC2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVIUC2__GetArrayViewFromImage(image)

def itkPyBufferVIUC2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned char >,2 > > const":
    """itkPyBufferVIUC2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned char >,2 > > const"""
    return _itkPyBufferPython.itkPyBufferVIUC2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVIUC3(object):
    """Proxy of C++ itkPyBufferVIUC3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageUC3') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageUC3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVIUC3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned char >,3 > > const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned char >,3 > > const"""
        return _itkPyBufferPython.itkPyBufferVIUC3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVIUC3 self) -> itkPyBufferVIUC3
        __init__(itkPyBufferVIUC3 self, itkPyBufferVIUC3 arg0) -> itkPyBufferVIUC3
        """
        _itkPyBufferPython.itkPyBufferVIUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "UC"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUC3._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIUC3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIUC3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVIUC3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUC3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVIUC3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVIUC3_swigregister = _itkPyBufferPython.itkPyBufferVIUC3_swigregister
itkPyBufferVIUC3_swigregister(itkPyBufferVIUC3)

def itkPyBufferVIUC3__GetArrayViewFromImage(image: 'itkVectorImageUC3') -> "PyObject *":
    """itkPyBufferVIUC3__GetArrayViewFromImage(itkVectorImageUC3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVIUC3__GetArrayViewFromImage(image)

def itkPyBufferVIUC3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned char >,3 > > const":
    """itkPyBufferVIUC3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned char >,3 > > const"""
    return _itkPyBufferPython.itkPyBufferVIUC3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVIUS2(object):
    """Proxy of C++ itkPyBufferVIUS2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageUS2') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageUS2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVIUS2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned short >,2 > > const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned short >,2 > > const"""
        return _itkPyBufferPython.itkPyBufferVIUS2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVIUS2 self) -> itkPyBufferVIUS2
        __init__(itkPyBufferVIUS2 self, itkPyBufferVIUS2 arg0) -> itkPyBufferVIUS2
        """
        _itkPyBufferPython.itkPyBufferVIUS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "US"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUS2._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIUS2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIUS2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVIUS2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUS2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVIUS2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVIUS2_swigregister = _itkPyBufferPython.itkPyBufferVIUS2_swigregister
itkPyBufferVIUS2_swigregister(itkPyBufferVIUS2)

def itkPyBufferVIUS2__GetArrayViewFromImage(image: 'itkVectorImageUS2') -> "PyObject *":
    """itkPyBufferVIUS2__GetArrayViewFromImage(itkVectorImageUS2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVIUS2__GetArrayViewFromImage(image)

def itkPyBufferVIUS2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned short >,2 > > const":
    """itkPyBufferVIUS2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned short >,2 > > const"""
    return _itkPyBufferPython.itkPyBufferVIUS2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVIUS3(object):
    """Proxy of C++ itkPyBufferVIUS3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageUS3') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageUS3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVIUS3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned short >,3 > > const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned short >,3 > > const"""
        return _itkPyBufferPython.itkPyBufferVIUS3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVIUS3 self) -> itkPyBufferVIUS3
        __init__(itkPyBufferVIUS3 self, itkPyBufferVIUS3 arg0) -> itkPyBufferVIUS3
        """
        _itkPyBufferPython.itkPyBufferVIUS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        Warning: No copy of the data is performed. Using an array
        view after its source image has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = []
        for idx in range(dim):
            shape.append(int(itksize[idx]))

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape = shape[::-1]

        pixelType     = "US"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUS3._GetArrayViewFromImage(image)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = numpy.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.

        Warning: No copy of the data is performed. Using an image
        view after its source array has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if( not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS'] ):
            raise ValueError("Array memory is not contiguous. Try converting your array with "
                  + "`ascontiguousarray()` or `copy()` or use `GetImageFromArray()`")

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIUS3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIUS3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVIUS3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *numpy.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *numpy.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUS3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVIUS3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVIUS3_swigregister = _itkPyBufferPython.itkPyBufferVIUS3_swigregister
itkPyBufferVIUS3_swigregister(itkPyBufferVIUS3)

def itkPyBufferVIUS3__GetArrayViewFromImage(image: 'itkVectorImageUS3') -> "PyObject *":
    """itkPyBufferVIUS3__GetArrayViewFromImage(itkVectorImageUS3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVIUS3__GetArrayViewFromImage(image)

def itkPyBufferVIUS3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned short >,3 > > const":
    """itkPyBufferVIUS3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itk::SmartPointer< itk::Image< itk::VariableLengthVector< unsigned short >,3 > > const"""
    return _itkPyBufferPython.itkPyBufferVIUS3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyVnlD(object):
    """Proxy of C++ itkPyVnlD class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorD') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorD vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorD const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorD"""
        return _itkPyBufferPython.itkPyVnlD__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixD') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixD matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixD const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixD"""
        return _itkPyBufferPython.itkPyVnlD__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlD self) -> itkPyVnlD
        __init__(itkPyVnlD self, itkPyVnlD arg0) -> itkPyVnlD
        """
        _itkPyBufferPython.itkPyVnlD_swiginit(self, _itkPyBufferPython.new_itkPyVnlD(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlD


    def GetArrayViewFromVnlVector(vnl_vector):
        """  Get a NumPy array view of a VNL vector.

        Warning: No copy of the data is performed. Using an array
        view after its source vector has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "D"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlD._GetArrayViewFromVnlVector(vnl_vector)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlD.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        vec = itkPyVnlD._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """  Get a NumPy array view of a VNL matrix.

        Warning: No copy of the data is performed. Using an array
        view after its source matrix has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "D"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlD._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlD.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        mat = itkPyVnlD._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlD_swigregister = _itkPyBufferPython.itkPyVnlD_swigregister
itkPyVnlD_swigregister(itkPyVnlD)

def itkPyVnlD__GetArrayViewFromVnlVector(vector: 'vnl_vectorD') -> "PyObject *":
    """itkPyVnlD__GetArrayViewFromVnlVector(vnl_vectorD vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlVector(vector)

def itkPyVnlD__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorD const":
    """itkPyVnlD__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorD"""
    return _itkPyBufferPython.itkPyVnlD__GetVnlVectorFromArray(arr, shape)

def itkPyVnlD__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixD') -> "PyObject *":
    """itkPyVnlD__GetArrayViewFromVnlMatrix(vnl_matrixD matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlD__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixD const":
    """itkPyVnlD__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixD"""
    return _itkPyBufferPython.itkPyVnlD__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlF(object):
    """Proxy of C++ itkPyVnlF class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorF') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorF vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorF const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorF"""
        return _itkPyBufferPython.itkPyVnlF__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixF') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixF matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixF const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixF"""
        return _itkPyBufferPython.itkPyVnlF__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlF self) -> itkPyVnlF
        __init__(itkPyVnlF self, itkPyVnlF arg0) -> itkPyVnlF
        """
        _itkPyBufferPython.itkPyVnlF_swiginit(self, _itkPyBufferPython.new_itkPyVnlF(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlF


    def GetArrayViewFromVnlVector(vnl_vector):
        """  Get a NumPy array view of a VNL vector.

        Warning: No copy of the data is performed. Using an array
        view after its source vector has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlF._GetArrayViewFromVnlVector(vnl_vector)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlF.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        vec = itkPyVnlF._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """  Get a NumPy array view of a VNL matrix.

        Warning: No copy of the data is performed. Using an array
        view after its source matrix has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "F"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlF._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlF.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        mat = itkPyVnlF._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlF_swigregister = _itkPyBufferPython.itkPyVnlF_swigregister
itkPyVnlF_swigregister(itkPyVnlF)

def itkPyVnlF__GetArrayViewFromVnlVector(vector: 'vnl_vectorF') -> "PyObject *":
    """itkPyVnlF__GetArrayViewFromVnlVector(vnl_vectorF vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlVector(vector)

def itkPyVnlF__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorF const":
    """itkPyVnlF__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorF"""
    return _itkPyBufferPython.itkPyVnlF__GetVnlVectorFromArray(arr, shape)

def itkPyVnlF__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixF') -> "PyObject *":
    """itkPyVnlF__GetArrayViewFromVnlMatrix(vnl_matrixF matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlF__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixF const":
    """itkPyVnlF__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixF"""
    return _itkPyBufferPython.itkPyVnlF__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlSC(object):
    """Proxy of C++ itkPyVnlSC class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorSC') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorSC vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSC const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSC"""
        return _itkPyBufferPython.itkPyVnlSC__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSC') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixSC matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSC const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSC"""
        return _itkPyBufferPython.itkPyVnlSC__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlSC self) -> itkPyVnlSC
        __init__(itkPyVnlSC self, itkPyVnlSC arg0) -> itkPyVnlSC
        """
        _itkPyBufferPython.itkPyVnlSC_swiginit(self, _itkPyBufferPython.new_itkPyVnlSC(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSC


    def GetArrayViewFromVnlVector(vnl_vector):
        """  Get a NumPy array view of a VNL vector.

        Warning: No copy of the data is performed. Using an array
        view after its source vector has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SC"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSC._GetArrayViewFromVnlVector(vnl_vector)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSC.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        vec = itkPyVnlSC._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """  Get a NumPy array view of a VNL matrix.

        Warning: No copy of the data is performed. Using an array
        view after its source matrix has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SC"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSC._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSC.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        mat = itkPyVnlSC._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlSC_swigregister = _itkPyBufferPython.itkPyVnlSC_swigregister
itkPyVnlSC_swigregister(itkPyVnlSC)

def itkPyVnlSC__GetArrayViewFromVnlVector(vector: 'vnl_vectorSC') -> "PyObject *":
    """itkPyVnlSC__GetArrayViewFromVnlVector(vnl_vectorSC vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlVector(vector)

def itkPyVnlSC__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSC const":
    """itkPyVnlSC__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSC"""
    return _itkPyBufferPython.itkPyVnlSC__GetVnlVectorFromArray(arr, shape)

def itkPyVnlSC__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSC') -> "PyObject *":
    """itkPyVnlSC__GetArrayViewFromVnlMatrix(vnl_matrixSC matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlSC__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSC const":
    """itkPyVnlSC__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSC"""
    return _itkPyBufferPython.itkPyVnlSC__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlSI(object):
    """Proxy of C++ itkPyVnlSI class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorSI') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorSI vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSI const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSI"""
        return _itkPyBufferPython.itkPyVnlSI__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSI') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixSI matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSI const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSI"""
        return _itkPyBufferPython.itkPyVnlSI__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlSI self) -> itkPyVnlSI
        __init__(itkPyVnlSI self, itkPyVnlSI arg0) -> itkPyVnlSI
        """
        _itkPyBufferPython.itkPyVnlSI_swiginit(self, _itkPyBufferPython.new_itkPyVnlSI(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSI


    def GetArrayViewFromVnlVector(vnl_vector):
        """  Get a NumPy array view of a VNL vector.

        Warning: No copy of the data is performed. Using an array
        view after its source vector has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SI"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSI._GetArrayViewFromVnlVector(vnl_vector)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSI.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        vec = itkPyVnlSI._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """  Get a NumPy array view of a VNL matrix.

        Warning: No copy of the data is performed. Using an array
        view after its source matrix has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SI"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSI._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSI.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        mat = itkPyVnlSI._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlSI_swigregister = _itkPyBufferPython.itkPyVnlSI_swigregister
itkPyVnlSI_swigregister(itkPyVnlSI)

def itkPyVnlSI__GetArrayViewFromVnlVector(vector: 'vnl_vectorSI') -> "PyObject *":
    """itkPyVnlSI__GetArrayViewFromVnlVector(vnl_vectorSI vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlVector(vector)

def itkPyVnlSI__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSI const":
    """itkPyVnlSI__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSI"""
    return _itkPyBufferPython.itkPyVnlSI__GetVnlVectorFromArray(arr, shape)

def itkPyVnlSI__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSI') -> "PyObject *":
    """itkPyVnlSI__GetArrayViewFromVnlMatrix(vnl_matrixSI matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlSI__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSI const":
    """itkPyVnlSI__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSI"""
    return _itkPyBufferPython.itkPyVnlSI__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlSL(object):
    """Proxy of C++ itkPyVnlSL class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorSL') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorSL vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSL const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSL"""
        return _itkPyBufferPython.itkPyVnlSL__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSL') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixSL matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSL const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSL"""
        return _itkPyBufferPython.itkPyVnlSL__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlSL self) -> itkPyVnlSL
        __init__(itkPyVnlSL self, itkPyVnlSL arg0) -> itkPyVnlSL
        """
        _itkPyBufferPython.itkPyVnlSL_swiginit(self, _itkPyBufferPython.new_itkPyVnlSL(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSL


    def GetArrayViewFromVnlVector(vnl_vector):
        """  Get a NumPy array view of a VNL vector.

        Warning: No copy of the data is performed. Using an array
        view after its source vector has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SL"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSL._GetArrayViewFromVnlVector(vnl_vector)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSL.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        vec = itkPyVnlSL._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """  Get a NumPy array view of a VNL matrix.

        Warning: No copy of the data is performed. Using an array
        view after its source matrix has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SL"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSL._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSL.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        mat = itkPyVnlSL._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlSL_swigregister = _itkPyBufferPython.itkPyVnlSL_swigregister
itkPyVnlSL_swigregister(itkPyVnlSL)

def itkPyVnlSL__GetArrayViewFromVnlVector(vector: 'vnl_vectorSL') -> "PyObject *":
    """itkPyVnlSL__GetArrayViewFromVnlVector(vnl_vectorSL vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlVector(vector)

def itkPyVnlSL__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSL const":
    """itkPyVnlSL__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSL"""
    return _itkPyBufferPython.itkPyVnlSL__GetVnlVectorFromArray(arr, shape)

def itkPyVnlSL__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSL') -> "PyObject *":
    """itkPyVnlSL__GetArrayViewFromVnlMatrix(vnl_matrixSL matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlSL__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSL const":
    """itkPyVnlSL__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSL"""
    return _itkPyBufferPython.itkPyVnlSL__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlSS(object):
    """Proxy of C++ itkPyVnlSS class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorSS') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorSS vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSS const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSS"""
        return _itkPyBufferPython.itkPyVnlSS__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSS') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixSS matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSS const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSS"""
        return _itkPyBufferPython.itkPyVnlSS__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlSS self) -> itkPyVnlSS
        __init__(itkPyVnlSS self, itkPyVnlSS arg0) -> itkPyVnlSS
        """
        _itkPyBufferPython.itkPyVnlSS_swiginit(self, _itkPyBufferPython.new_itkPyVnlSS(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSS


    def GetArrayViewFromVnlVector(vnl_vector):
        """  Get a NumPy array view of a VNL vector.

        Warning: No copy of the data is performed. Using an array
        view after its source vector has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SS"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSS._GetArrayViewFromVnlVector(vnl_vector)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSS.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        vec = itkPyVnlSS._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """  Get a NumPy array view of a VNL matrix.

        Warning: No copy of the data is performed. Using an array
        view after its source matrix has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SS"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSS._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSS.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        mat = itkPyVnlSS._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlSS_swigregister = _itkPyBufferPython.itkPyVnlSS_swigregister
itkPyVnlSS_swigregister(itkPyVnlSS)

def itkPyVnlSS__GetArrayViewFromVnlVector(vector: 'vnl_vectorSS') -> "PyObject *":
    """itkPyVnlSS__GetArrayViewFromVnlVector(vnl_vectorSS vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlVector(vector)

def itkPyVnlSS__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSS const":
    """itkPyVnlSS__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSS"""
    return _itkPyBufferPython.itkPyVnlSS__GetVnlVectorFromArray(arr, shape)

def itkPyVnlSS__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSS') -> "PyObject *":
    """itkPyVnlSS__GetArrayViewFromVnlMatrix(vnl_matrixSS matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlSS__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSS const":
    """itkPyVnlSS__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSS"""
    return _itkPyBufferPython.itkPyVnlSS__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlUC(object):
    """Proxy of C++ itkPyVnlUC class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorUC') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorUC vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUC const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUC"""
        return _itkPyBufferPython.itkPyVnlUC__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUC') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixUC matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUC const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUC"""
        return _itkPyBufferPython.itkPyVnlUC__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlUC self) -> itkPyVnlUC
        __init__(itkPyVnlUC self, itkPyVnlUC arg0) -> itkPyVnlUC
        """
        _itkPyBufferPython.itkPyVnlUC_swiginit(self, _itkPyBufferPython.new_itkPyVnlUC(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUC


    def GetArrayViewFromVnlVector(vnl_vector):
        """  Get a NumPy array view of a VNL vector.

        Warning: No copy of the data is performed. Using an array
        view after its source vector has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "UC"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUC._GetArrayViewFromVnlVector(vnl_vector)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUC.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        vec = itkPyVnlUC._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """  Get a NumPy array view of a VNL matrix.

        Warning: No copy of the data is performed. Using an array
        view after its source matrix has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "UC"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUC._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUC.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        mat = itkPyVnlUC._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlUC_swigregister = _itkPyBufferPython.itkPyVnlUC_swigregister
itkPyVnlUC_swigregister(itkPyVnlUC)

def itkPyVnlUC__GetArrayViewFromVnlVector(vector: 'vnl_vectorUC') -> "PyObject *":
    """itkPyVnlUC__GetArrayViewFromVnlVector(vnl_vectorUC vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlVector(vector)

def itkPyVnlUC__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUC const":
    """itkPyVnlUC__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUC"""
    return _itkPyBufferPython.itkPyVnlUC__GetVnlVectorFromArray(arr, shape)

def itkPyVnlUC__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUC') -> "PyObject *":
    """itkPyVnlUC__GetArrayViewFromVnlMatrix(vnl_matrixUC matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlUC__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUC const":
    """itkPyVnlUC__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUC"""
    return _itkPyBufferPython.itkPyVnlUC__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlUI(object):
    """Proxy of C++ itkPyVnlUI class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorUI') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorUI vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUI const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUI"""
        return _itkPyBufferPython.itkPyVnlUI__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUI') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixUI matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUI const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUI"""
        return _itkPyBufferPython.itkPyVnlUI__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlUI self) -> itkPyVnlUI
        __init__(itkPyVnlUI self, itkPyVnlUI arg0) -> itkPyVnlUI
        """
        _itkPyBufferPython.itkPyVnlUI_swiginit(self, _itkPyBufferPython.new_itkPyVnlUI(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUI


    def GetArrayViewFromVnlVector(vnl_vector):
        """  Get a NumPy array view of a VNL vector.

        Warning: No copy of the data is performed. Using an array
        view after its source vector has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "UI"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUI._GetArrayViewFromVnlVector(vnl_vector)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUI.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        vec = itkPyVnlUI._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """  Get a NumPy array view of a VNL matrix.

        Warning: No copy of the data is performed. Using an array
        view after its source matrix has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "UI"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUI._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUI.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        mat = itkPyVnlUI._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlUI_swigregister = _itkPyBufferPython.itkPyVnlUI_swigregister
itkPyVnlUI_swigregister(itkPyVnlUI)

def itkPyVnlUI__GetArrayViewFromVnlVector(vector: 'vnl_vectorUI') -> "PyObject *":
    """itkPyVnlUI__GetArrayViewFromVnlVector(vnl_vectorUI vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlVector(vector)

def itkPyVnlUI__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUI const":
    """itkPyVnlUI__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUI"""
    return _itkPyBufferPython.itkPyVnlUI__GetVnlVectorFromArray(arr, shape)

def itkPyVnlUI__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUI') -> "PyObject *":
    """itkPyVnlUI__GetArrayViewFromVnlMatrix(vnl_matrixUI matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlUI__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUI const":
    """itkPyVnlUI__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUI"""
    return _itkPyBufferPython.itkPyVnlUI__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlUL(object):
    """Proxy of C++ itkPyVnlUL class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorUL') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorUL vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUL const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUL"""
        return _itkPyBufferPython.itkPyVnlUL__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUL') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixUL matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUL const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUL"""
        return _itkPyBufferPython.itkPyVnlUL__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlUL self) -> itkPyVnlUL
        __init__(itkPyVnlUL self, itkPyVnlUL arg0) -> itkPyVnlUL
        """
        _itkPyBufferPython.itkPyVnlUL_swiginit(self, _itkPyBufferPython.new_itkPyVnlUL(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUL


    def GetArrayViewFromVnlVector(vnl_vector):
        """  Get a NumPy array view of a VNL vector.

        Warning: No copy of the data is performed. Using an array
        view after its source vector has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "UL"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUL._GetArrayViewFromVnlVector(vnl_vector)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUL.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        vec = itkPyVnlUL._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """  Get a NumPy array view of a VNL matrix.

        Warning: No copy of the data is performed. Using an array
        view after its source matrix has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "UL"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUL._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUL.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        mat = itkPyVnlUL._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlUL_swigregister = _itkPyBufferPython.itkPyVnlUL_swigregister
itkPyVnlUL_swigregister(itkPyVnlUL)

def itkPyVnlUL__GetArrayViewFromVnlVector(vector: 'vnl_vectorUL') -> "PyObject *":
    """itkPyVnlUL__GetArrayViewFromVnlVector(vnl_vectorUL vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlVector(vector)

def itkPyVnlUL__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUL const":
    """itkPyVnlUL__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUL"""
    return _itkPyBufferPython.itkPyVnlUL__GetVnlVectorFromArray(arr, shape)

def itkPyVnlUL__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUL') -> "PyObject *":
    """itkPyVnlUL__GetArrayViewFromVnlMatrix(vnl_matrixUL matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlUL__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUL const":
    """itkPyVnlUL__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUL"""
    return _itkPyBufferPython.itkPyVnlUL__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlUS(object):
    """Proxy of C++ itkPyVnlUS class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorUS') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorUS vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUS const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUS"""
        return _itkPyBufferPython.itkPyVnlUS__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUS') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixUS matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUS const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUS"""
        return _itkPyBufferPython.itkPyVnlUS__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlUS self) -> itkPyVnlUS
        __init__(itkPyVnlUS self, itkPyVnlUS arg0) -> itkPyVnlUS
        """
        _itkPyBufferPython.itkPyVnlUS_swiginit(self, _itkPyBufferPython.new_itkPyVnlUS(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUS


    def GetArrayViewFromVnlVector(vnl_vector):
        """  Get a NumPy array view of a VNL vector.

        Warning: No copy of the data is performed. Using an array
        view after its source vector has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "US"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUS._GetArrayViewFromVnlVector(vnl_vector)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUS.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        vec = itkPyVnlUS._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """  Get a NumPy array view of a VNL matrix.

        Warning: No copy of the data is performed. Using an array
        view after its source matrix has been deleted can results in corrupt values
        or a segfault.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "US"
        numpydatatype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUS._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarrview  = numpy.asarray(memview).view(dtype = numpydatatype).reshape(shape).view(numpy.ndarray)

        return ndarrview

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUS.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return numpy.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        mat = itkPyVnlUS._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlUS_swigregister = _itkPyBufferPython.itkPyVnlUS_swigregister
itkPyVnlUS_swigregister(itkPyVnlUS)

def itkPyVnlUS__GetArrayViewFromVnlVector(vector: 'vnl_vectorUS') -> "PyObject *":
    """itkPyVnlUS__GetArrayViewFromVnlVector(vnl_vectorUS vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlVector(vector)

def itkPyVnlUS__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUS const":
    """itkPyVnlUS__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUS"""
    return _itkPyBufferPython.itkPyVnlUS__GetVnlVectorFromArray(arr, shape)

def itkPyVnlUS__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUS') -> "PyObject *":
    """itkPyVnlUS__GetArrayViewFromVnlMatrix(vnl_matrixUS matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlUS__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUS const":
    """itkPyVnlUS__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUS"""
    return _itkPyBufferPython.itkPyVnlUS__GetVnlMatrixFromArray(arr, shape)



